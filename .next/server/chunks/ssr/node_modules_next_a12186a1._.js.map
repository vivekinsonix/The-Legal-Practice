{"version":3,"sources":["../../../../node_modules/next/src/server/web/spec-extension/cookies.ts","../../../../node_modules/next/src/server/web/spec-extension/adapters/reflect.ts","../../../../node_modules/next/src/server/web/spec-extension/adapters/request-cookies.ts","../../../../node_modules/next/src/server/create-deduped-by-callsite-server-error-logger.ts","../../../../node_modules/next/src/server/request/utils.ts","../../../../node_modules/next/src/server/request/cookies.ts","../../../../node_modules/next/src/server/web/spec-extension/adapters/headers.ts","../../../../node_modules/next/src/server/request/headers.ts","../../../../node_modules/next/src/server/request/draft-mode.ts","../../../../node_modules/next/headers.js"],"sourcesContent":["export {\n  RequestCookies,\n  ResponseCookies,\n  stringifyCookie,\n} from 'next/dist/compiled/@edge-runtime/cookies'\n","export class ReflectAdapter {\n  static get<T extends object>(\n    target: T,\n    prop: string | symbol,\n    receiver: unknown\n  ): any {\n    const value = Reflect.get(target, prop, receiver)\n    if (typeof value === 'function') {\n      return value.bind(target)\n    }\n\n    return value\n  }\n\n  static set<T extends object>(\n    target: T,\n    prop: string | symbol,\n    value: any,\n    receiver: any\n  ): boolean {\n    return Reflect.set(target, prop, value, receiver)\n  }\n\n  static has<T extends object>(target: T, prop: string | symbol): boolean {\n    return Reflect.has(target, prop)\n  }\n\n  static deleteProperty<T extends object>(\n    target: T,\n    prop: string | symbol\n  ): boolean {\n    return Reflect.deleteProperty(target, prop)\n  }\n}\n","import { RequestCookies } from '../cookies'\n\nimport { ResponseCookies } from '../cookies'\nimport { ReflectAdapter } from './reflect'\nimport { workAsyncStorage } from '../../../app-render/work-async-storage.external'\nimport type { RequestStore } from '../../../app-render/work-unit-async-storage.external'\n\n/**\n * @internal\n */\nexport class ReadonlyRequestCookiesError extends Error {\n  constructor() {\n    super(\n      'Cookies can only be modified in a Server Action or Route Handler. Read more: https://nextjs.org/docs/app/api-reference/functions/cookies#options'\n    )\n  }\n\n  public static callable() {\n    throw new ReadonlyRequestCookiesError()\n  }\n}\n\n// We use this to type some APIs but we don't construct instances directly\nexport type { ResponseCookies }\n\n// The `cookies()` API is a mix of request and response cookies. For `.get()` methods,\n// we want to return the request cookie if it exists. For mutative methods like `.set()`,\n// we want to return the response cookie.\nexport type ReadonlyRequestCookies = Omit<\n  RequestCookies,\n  'set' | 'clear' | 'delete'\n> &\n  Pick<ResponseCookies, 'set' | 'delete'>\n\nexport class RequestCookiesAdapter {\n  public static seal(cookies: RequestCookies): ReadonlyRequestCookies {\n    return new Proxy(cookies as any, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          case 'clear':\n          case 'delete':\n          case 'set':\n            return ReadonlyRequestCookiesError.callable\n          default:\n            return ReflectAdapter.get(target, prop, receiver)\n        }\n      },\n    })\n  }\n}\n\nconst SYMBOL_MODIFY_COOKIE_VALUES = Symbol.for('next.mutated.cookies')\n\nexport function getModifiedCookieValues(\n  cookies: ResponseCookies\n): ResponseCookie[] {\n  const modified: ResponseCookie[] | undefined = (cookies as unknown as any)[\n    SYMBOL_MODIFY_COOKIE_VALUES\n  ]\n  if (!modified || !Array.isArray(modified) || modified.length === 0) {\n    return []\n  }\n\n  return modified\n}\n\ntype SetCookieArgs =\n  | [key: string, value: string, cookie?: Partial<ResponseCookie>]\n  | [options: ResponseCookie]\n\nexport function appendMutableCookies(\n  headers: Headers,\n  mutableCookies: ResponseCookies\n): boolean {\n  const modifiedCookieValues = getModifiedCookieValues(mutableCookies)\n  if (modifiedCookieValues.length === 0) {\n    return false\n  }\n\n  // Return a new response that extends the response with\n  // the modified cookies as fallbacks. `res` cookies\n  // will still take precedence.\n  const resCookies = new ResponseCookies(headers)\n  const returnedCookies = resCookies.getAll()\n\n  // Set the modified cookies as fallbacks.\n  for (const cookie of modifiedCookieValues) {\n    resCookies.set(cookie)\n  }\n\n  // Set the original cookies as the final values.\n  for (const cookie of returnedCookies) {\n    resCookies.set(cookie)\n  }\n\n  return true\n}\n\ntype ResponseCookie = NonNullable<\n  ReturnType<InstanceType<typeof ResponseCookies>['get']>\n>\n\nexport class MutableRequestCookiesAdapter {\n  public static wrap(\n    cookies: RequestCookies,\n    onUpdateCookies?: (cookies: string[]) => void\n  ): ResponseCookies {\n    const responseCookies = new ResponseCookies(new Headers())\n    for (const cookie of cookies.getAll()) {\n      responseCookies.set(cookie)\n    }\n\n    let modifiedValues: ResponseCookie[] = []\n    const modifiedCookies = new Set<string>()\n    const updateResponseCookies = () => {\n      // TODO-APP: change method of getting workStore\n      const workStore = workAsyncStorage.getStore()\n      if (workStore) {\n        workStore.pathWasRevalidated = true\n      }\n\n      const allCookies = responseCookies.getAll()\n      modifiedValues = allCookies.filter((c) => modifiedCookies.has(c.name))\n      if (onUpdateCookies) {\n        const serializedCookies: string[] = []\n        for (const cookie of modifiedValues) {\n          const tempCookies = new ResponseCookies(new Headers())\n          tempCookies.set(cookie)\n          serializedCookies.push(tempCookies.toString())\n        }\n\n        onUpdateCookies(serializedCookies)\n      }\n    }\n\n    const wrappedCookies = new Proxy(responseCookies, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          // A special symbol to get the modified cookie values\n          case SYMBOL_MODIFY_COOKIE_VALUES:\n            return modifiedValues\n\n          // TODO: Throw error if trying to set a cookie after the response\n          // headers have been set.\n          case 'delete':\n            return function (...args: [string] | [ResponseCookie]) {\n              modifiedCookies.add(\n                typeof args[0] === 'string' ? args[0] : args[0].name\n              )\n              try {\n                target.delete(...args)\n                return wrappedCookies\n              } finally {\n                updateResponseCookies()\n              }\n            }\n          case 'set':\n            return function (...args: SetCookieArgs) {\n              modifiedCookies.add(\n                typeof args[0] === 'string' ? args[0] : args[0].name\n              )\n              try {\n                target.set(...args)\n                return wrappedCookies\n              } finally {\n                updateResponseCookies()\n              }\n            }\n\n          default:\n            return ReflectAdapter.get(target, prop, receiver)\n        }\n      },\n    })\n\n    return wrappedCookies\n  }\n}\n\nexport function createCookiesWithMutableAccessCheck(\n  requestStore: RequestStore\n): ResponseCookies {\n  const wrappedCookies = new Proxy(requestStore.mutableCookies, {\n    get(target, prop, receiver) {\n      switch (prop) {\n        case 'delete':\n          return function (...args: [string] | [ResponseCookie]) {\n            ensureCookiesAreStillMutable(requestStore, 'cookies().delete')\n            target.delete(...args)\n            return wrappedCookies\n          }\n        case 'set':\n          return function (...args: SetCookieArgs) {\n            ensureCookiesAreStillMutable(requestStore, 'cookies().set')\n            target.set(...args)\n            return wrappedCookies\n          }\n\n        default:\n          return ReflectAdapter.get(target, prop, receiver)\n      }\n    },\n  })\n  return wrappedCookies\n}\n\nexport function areCookiesMutableInCurrentPhase(requestStore: RequestStore) {\n  return requestStore.phase === 'action'\n}\n\n/** Ensure that cookies() starts throwing on mutation\n * if we changed phases and can no longer mutate.\n *\n * This can happen when going:\n *   'render' -> 'after'\n *   'action' -> 'render'\n * */\nfunction ensureCookiesAreStillMutable(\n  requestStore: RequestStore,\n  _callingExpression: string\n) {\n  if (!areCookiesMutableInCurrentPhase(requestStore)) {\n    // TODO: maybe we can give a more precise error message based on callingExpression?\n    throw new ReadonlyRequestCookiesError()\n  }\n}\n\nexport function responseCookiesToRequestCookies(\n  responseCookies: ResponseCookies\n): RequestCookies {\n  const requestCookies = new RequestCookies(new Headers())\n  for (const cookie of responseCookies.getAll()) {\n    requestCookies.set(cookie)\n  }\n  return requestCookies\n}\n","import * as React from 'react'\n\nconst errorRef: { current: null | Error } = { current: null }\n\n// React.cache is currently only available in canary/experimental React channels.\nconst cache =\n  typeof React.cache === 'function'\n    ? React.cache\n    : (fn: (key: unknown) => void) => fn\n\n// When Cache Components is enabled, we record these as errors so that they\n// are captured by the dev overlay as it's more critical to fix these\n// when enabled.\nconst logErrorOrWarn = process.env.__NEXT_CACHE_COMPONENTS\n  ? console.error\n  : console.warn\n\n// We don't want to dedupe across requests.\n// The developer might've just attempted to fix the warning so we should warn again if it still happens.\nconst flushCurrentErrorIfNew = cache(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- cache key\n  (key: unknown) => {\n    try {\n      logErrorOrWarn(errorRef.current)\n    } finally {\n      errorRef.current = null\n    }\n  }\n)\n\n/**\n * Creates a function that logs an error message that is deduped by the userland\n * callsite.\n * This requires no indirection between the call of this function and the userland\n * callsite i.e. there's only a single library frame above this.\n * Do not use on the Client where sourcemaps and ignore listing might be enabled.\n * Only use that for warnings need a fix independent of the callstack.\n *\n * @param getMessage\n * @returns\n */\nexport function createDedupedByCallsiteServerErrorLoggerDev<Args extends any[]>(\n  getMessage: (...args: Args) => Error\n) {\n  return function logDedupedError(...args: Args) {\n    const message = getMessage(...args)\n\n    if (process.env.NODE_ENV !== 'production') {\n      const callStackFrames = new Error().stack?.split('\\n')\n      if (callStackFrames === undefined || callStackFrames.length < 4) {\n        logErrorOrWarn(message)\n      } else {\n        // Error:\n        //   logDedupedError\n        //   asyncApiBeingAccessedSynchronously\n        //   <userland callsite>\n        // TODO: This breaks if sourcemaps with ignore lists are enabled.\n        const key = callStackFrames[4]\n        errorRef.current = message\n        flushCurrentErrorIfNew(key)\n      }\n    } else {\n      logErrorOrWarn(message)\n    }\n  }\n}\n","import { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { afterTaskAsyncStorage } from '../app-render/after-task-async-storage.external'\nimport type { WorkStore } from '../app-render/work-async-storage.external'\n\nexport function throwWithStaticGenerationBailoutErrorWithDynamicError(\n  route: string,\n  expression: string\n): never {\n  throw new StaticGenBailoutError(\n    `Route ${route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n  )\n}\n\nexport function throwForSearchParamsAccessInUseCache(\n  workStore: WorkStore,\n  constructorOpt: Function\n): never {\n  const error = new Error(\n    `Route ${workStore.route} used \\`searchParams\\` inside \"use cache\". Accessing dynamic request data inside a cache scope is not supported. If you need some search params inside a cached function await \\`searchParams\\` outside of the cached function and pass only the required search params as arguments to the cached function. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n  )\n\n  Error.captureStackTrace(error, constructorOpt)\n  workStore.invalidDynamicUsageError ??= error\n\n  throw error\n}\n\nexport function isRequestAPICallableInsideAfter() {\n  const afterTaskStore = afterTaskAsyncStorage.getStore()\n  return afterTaskStore?.rootTaskSpawnPhase === 'action'\n}\n","import {\n  type ReadonlyRequestCookies,\n  areCookiesMutableInCurrentPhase,\n  RequestCookiesAdapter,\n} from '../web/spec-extension/adapters/request-cookies'\nimport { RequestCookies } from '../web/spec-extension/cookies'\nimport {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport {\n  throwForMissingRequestStore,\n  workUnitAsyncStorage,\n  type PrerenderStoreModern,\n  type RequestStore,\n} from '../app-render/work-unit-async-storage.external'\nimport {\n  delayUntilRuntimeStage,\n  postponeWithTracking,\n  throwToInterruptStaticGeneration,\n  trackDynamicDataInDynamicRender,\n} from '../app-render/dynamic-rendering'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport {\n  makeDevtoolsIOAwarePromise,\n  makeHangingPromise,\n} from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { isRequestAPICallableInsideAfter } from './utils'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { RenderStage } from '../app-render/staged-rendering'\n\nexport function cookies(): Promise<ReadonlyRequestCookies> {\n  const callingExpression = 'cookies'\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workStore) {\n    if (\n      workUnitStore &&\n      workUnitStore.phase === 'after' &&\n      !isRequestAPICallableInsideAfter()\n    ) {\n      throw new Error(\n        // TODO(after): clarify that this only applies to pages?\n        `Route ${workStore.route} used \\`cookies()\\` inside \\`after()\\`. This is not supported. If you need this data inside an \\`after()\\` callback, use \\`cookies()\\` outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`\n      )\n    }\n\n    if (workStore.forceStatic) {\n      // When using forceStatic we override all other logic and always just return an empty\n      // cookies object without tracking\n      const underlyingCookies = createEmptyCookies()\n      return makeUntrackedCookies(underlyingCookies)\n    }\n\n    if (workStore.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`cookies()\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      switch (workUnitStore.type) {\n        case 'cache':\n          const error = new Error(\n            `Route ${workStore.route} used \\`cookies()\\` inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`cookies()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n          )\n          Error.captureStackTrace(error, cookies)\n          workStore.invalidDynamicUsageError ??= error\n          throw error\n        case 'unstable-cache':\n          throw new Error(\n            `Route ${workStore.route} used \\`cookies()\\` inside a function cached with \\`unstable_cache()\\`. Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`cookies()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n          )\n        case 'prerender':\n          return makeHangingCookies(workStore, workUnitStore)\n        case 'prerender-client':\n          const exportName = '`cookies`'\n          throw new InvariantError(\n            `${exportName} must not be used within a Client Component. Next.js should be preventing ${exportName} from being included in Client Components statically, but did not in this case.`\n          )\n        case 'prerender-ppr':\n          // We need track dynamic access here eagerly to keep continuity with\n          // how cookies has worked in PPR without cacheComponents.\n          return postponeWithTracking(\n            workStore.route,\n            callingExpression,\n            workUnitStore.dynamicTracking\n          )\n        case 'prerender-legacy':\n          // We track dynamic access here so we don't need to wrap the cookies\n          // in individual property access tracking.\n          return throwToInterruptStaticGeneration(\n            callingExpression,\n            workStore,\n            workUnitStore\n          )\n        case 'prerender-runtime':\n          return delayUntilRuntimeStage(\n            workUnitStore,\n            makeUntrackedCookies(workUnitStore.cookies)\n          )\n        case 'private-cache':\n          // Private caches are delayed until the runtime stage in use-cache-wrapper,\n          // so we don't need an additional delay here.\n          return makeUntrackedCookies(workUnitStore.cookies)\n        case 'request':\n          trackDynamicDataInDynamicRender(workUnitStore)\n\n          let underlyingCookies: ReadonlyRequestCookies\n\n          if (areCookiesMutableInCurrentPhase(workUnitStore)) {\n            // We can't conditionally return different types here based on the context.\n            // To avoid confusion, we always return the readonly type here.\n            underlyingCookies =\n              workUnitStore.userspaceMutableCookies as unknown as ReadonlyRequestCookies\n          } else {\n            underlyingCookies = workUnitStore.cookies\n          }\n\n          if (process.env.NODE_ENV === 'development') {\n            // Semantically we only need the dev tracking when running in `next dev`\n            // but since you would never use next dev with production NODE_ENV we use this\n            // as a proxy so we can statically exclude this code from production builds.\n            return makeUntrackedCookiesWithDevWarnings(\n              workUnitStore,\n              underlyingCookies,\n              workStore?.route\n            )\n          } else {\n            return makeUntrackedCookies(underlyingCookies)\n          }\n        default:\n          workUnitStore satisfies never\n      }\n    }\n  }\n\n  // If we end up here, there was no work store or work unit store present.\n  throwForMissingRequestStore(callingExpression)\n}\n\nfunction createEmptyCookies(): ReadonlyRequestCookies {\n  return RequestCookiesAdapter.seal(new RequestCookies(new Headers({})))\n}\n\ninterface CacheLifetime {}\nconst CachedCookies = new WeakMap<\n  CacheLifetime,\n  Promise<ReadonlyRequestCookies>\n>()\n\nfunction makeHangingCookies(\n  workStore: WorkStore,\n  prerenderStore: PrerenderStoreModern\n): Promise<ReadonlyRequestCookies> {\n  const cachedPromise = CachedCookies.get(prerenderStore)\n  if (cachedPromise) {\n    return cachedPromise\n  }\n\n  const promise = makeHangingPromise<ReadonlyRequestCookies>(\n    prerenderStore.renderSignal,\n    workStore.route,\n    '`cookies()`'\n  )\n  CachedCookies.set(prerenderStore, promise)\n\n  return promise\n}\n\nfunction makeUntrackedCookies(\n  underlyingCookies: ReadonlyRequestCookies\n): Promise<ReadonlyRequestCookies> {\n  const cachedCookies = CachedCookies.get(underlyingCookies)\n  if (cachedCookies) {\n    return cachedCookies\n  }\n\n  const promise = Promise.resolve(underlyingCookies)\n  CachedCookies.set(underlyingCookies, promise)\n\n  return promise\n}\n\nfunction makeUntrackedCookiesWithDevWarnings(\n  requestStore: RequestStore,\n  underlyingCookies: ReadonlyRequestCookies,\n  route?: string\n): Promise<ReadonlyRequestCookies> {\n  if (requestStore.asyncApiPromises) {\n    let promise: Promise<ReadonlyRequestCookies>\n    if (underlyingCookies === requestStore.mutableCookies) {\n      promise = requestStore.asyncApiPromises.mutableCookies\n    } else if (underlyingCookies === requestStore.cookies) {\n      promise = requestStore.asyncApiPromises.cookies\n    } else {\n      throw new InvariantError(\n        'Received an underlying cookies object that does not match either `cookies` or `mutableCookies`'\n      )\n    }\n    return instrumentCookiesPromiseWithDevWarnings(promise, route)\n  }\n\n  const cachedCookies = CachedCookies.get(underlyingCookies)\n  if (cachedCookies) {\n    return cachedCookies\n  }\n\n  const promise = makeDevtoolsIOAwarePromise(\n    underlyingCookies,\n    requestStore,\n    RenderStage.Runtime\n  )\n\n  const proxiedPromise = instrumentCookiesPromiseWithDevWarnings(promise, route)\n\n  CachedCookies.set(underlyingCookies, proxiedPromise)\n\n  return proxiedPromise\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createCookiesAccessError\n)\n\nfunction instrumentCookiesPromiseWithDevWarnings(\n  promise: Promise<ReadonlyRequestCookies>,\n  route: string | undefined\n) {\n  Object.defineProperties(promise, {\n    [Symbol.iterator]: replaceableWarningDescriptorForSymbolIterator(\n      promise,\n      route\n    ),\n    size: replaceableWarningDescriptor(promise, 'size', route),\n    get: replaceableWarningDescriptor(promise, 'get', route),\n    getAll: replaceableWarningDescriptor(promise, 'getAll', route),\n    has: replaceableWarningDescriptor(promise, 'has', route),\n    set: replaceableWarningDescriptor(promise, 'set', route),\n    delete: replaceableWarningDescriptor(promise, 'delete', route),\n    clear: replaceableWarningDescriptor(promise, 'clear', route),\n    toString: replaceableWarningDescriptor(promise, 'toString', route),\n  })\n  return promise\n}\n\nfunction replaceableWarningDescriptor(\n  target: unknown,\n  prop: string,\n  route: string | undefined\n) {\n  return {\n    enumerable: false,\n    get() {\n      warnForSyncAccess(route, `\\`cookies().${prop}\\``)\n      return undefined\n    },\n    set(value: unknown) {\n      Object.defineProperty(target, prop, {\n        value,\n        writable: true,\n        configurable: true,\n      })\n    },\n    configurable: true,\n  }\n}\n\nfunction replaceableWarningDescriptorForSymbolIterator(\n  target: unknown,\n  route: string | undefined\n) {\n  return {\n    enumerable: false,\n    get() {\n      warnForSyncAccess(route, '`...cookies()` or similar iteration')\n      return undefined\n    },\n    set(value: unknown) {\n      Object.defineProperty(target, Symbol.iterator, {\n        value,\n        writable: true,\n        enumerable: true,\n        configurable: true,\n      })\n    },\n    configurable: true,\n  }\n}\n\nfunction createCookiesAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`cookies()\\` returns a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n","import type { IncomingHttpHeaders } from 'http'\n\nimport { ReflectAdapter } from './reflect'\n\n/**\n * @internal\n */\nexport class ReadonlyHeadersError extends Error {\n  constructor() {\n    super(\n      'Headers cannot be modified. Read more: https://nextjs.org/docs/app/api-reference/functions/headers'\n    )\n  }\n\n  public static callable() {\n    throw new ReadonlyHeadersError()\n  }\n}\n\nexport type ReadonlyHeaders = Headers & {\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  append(...args: any[]): void\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  set(...args: any[]): void\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  delete(...args: any[]): void\n}\nexport class HeadersAdapter extends Headers {\n  private readonly headers: IncomingHttpHeaders\n\n  constructor(headers: IncomingHttpHeaders) {\n    // We've already overridden the methods that would be called, so we're just\n    // calling the super constructor to ensure that the instanceof check works.\n    super()\n\n    this.headers = new Proxy(headers, {\n      get(target, prop, receiver) {\n        // Because this is just an object, we expect that all \"get\" operations\n        // are for properties. If it's a \"get\" for a symbol, we'll just return\n        // the symbol.\n        if (typeof prop === 'symbol') {\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, return undefined.\n        if (typeof original === 'undefined') return\n\n        // If the original casing exists, return the value.\n        return ReflectAdapter.get(target, original, receiver)\n      },\n      set(target, prop, value, receiver) {\n        if (typeof prop === 'symbol') {\n          return ReflectAdapter.set(target, prop, value, receiver)\n        }\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, use the prop as the key.\n        return ReflectAdapter.set(target, original ?? prop, value, receiver)\n      },\n      has(target, prop) {\n        if (typeof prop === 'symbol') return ReflectAdapter.has(target, prop)\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, return false.\n        if (typeof original === 'undefined') return false\n\n        // If the original casing exists, return true.\n        return ReflectAdapter.has(target, original)\n      },\n      deleteProperty(target, prop) {\n        if (typeof prop === 'symbol')\n          return ReflectAdapter.deleteProperty(target, prop)\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, return true.\n        if (typeof original === 'undefined') return true\n\n        // If the original casing exists, delete the property.\n        return ReflectAdapter.deleteProperty(target, original)\n      },\n    })\n  }\n\n  /**\n   * Seals a Headers instance to prevent modification by throwing an error when\n   * any mutating method is called.\n   */\n  public static seal(headers: Headers): ReadonlyHeaders {\n    return new Proxy<ReadonlyHeaders>(headers, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          case 'append':\n          case 'delete':\n          case 'set':\n            return ReadonlyHeadersError.callable\n          default:\n            return ReflectAdapter.get(target, prop, receiver)\n        }\n      },\n    })\n  }\n\n  /**\n   * Merges a header value into a string. This stores multiple values as an\n   * array, so we need to merge them into a string.\n   *\n   * @param value a header value\n   * @returns a merged header value (a string)\n   */\n  private merge(value: string | string[]): string {\n    if (Array.isArray(value)) return value.join(', ')\n\n    return value\n  }\n\n  /**\n   * Creates a Headers instance from a plain object or a Headers instance.\n   *\n   * @param headers a plain object or a Headers instance\n   * @returns a headers instance\n   */\n  public static from(headers: IncomingHttpHeaders | Headers): Headers {\n    if (headers instanceof Headers) return headers\n\n    return new HeadersAdapter(headers)\n  }\n\n  public append(name: string, value: string): void {\n    const existing = this.headers[name]\n    if (typeof existing === 'string') {\n      this.headers[name] = [existing, value]\n    } else if (Array.isArray(existing)) {\n      existing.push(value)\n    } else {\n      this.headers[name] = value\n    }\n  }\n\n  public delete(name: string): void {\n    delete this.headers[name]\n  }\n\n  public get(name: string): string | null {\n    const value = this.headers[name]\n    if (typeof value !== 'undefined') return this.merge(value)\n\n    return null\n  }\n\n  public has(name: string): boolean {\n    return typeof this.headers[name] !== 'undefined'\n  }\n\n  public set(name: string, value: string): void {\n    this.headers[name] = value\n  }\n\n  public forEach(\n    callbackfn: (value: string, name: string, parent: Headers) => void,\n    thisArg?: any\n  ): void {\n    for (const [name, value] of this.entries()) {\n      callbackfn.call(thisArg, value, name, this)\n    }\n  }\n\n  public *entries(): HeadersIterator<[string, string]> {\n    for (const key of Object.keys(this.headers)) {\n      const name = key.toLowerCase()\n      // We assert here that this is a string because we got it from the\n      // Object.keys() call above.\n      const value = this.get(name) as string\n\n      yield [name, value] as [string, string]\n    }\n  }\n\n  public *keys(): HeadersIterator<string> {\n    for (const key of Object.keys(this.headers)) {\n      const name = key.toLowerCase()\n      yield name\n    }\n  }\n\n  public *values(): HeadersIterator<string> {\n    for (const key of Object.keys(this.headers)) {\n      // We assert here that this is a string because we got it from the\n      // Object.keys() call above.\n      const value = this.get(key) as string\n\n      yield value\n    }\n  }\n\n  public [Symbol.iterator](): HeadersIterator<[string, string]> {\n    return this.entries()\n  }\n}\n","import {\n  HeadersAdapter,\n  type ReadonlyHeaders,\n} from '../web/spec-extension/adapters/headers'\nimport {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport {\n  throwForMissingRequestStore,\n  workUnitAsyncStorage,\n  type PrerenderStoreModern,\n  type RequestStore,\n} from '../app-render/work-unit-async-storage.external'\nimport {\n  delayUntilRuntimeStage,\n  postponeWithTracking,\n  throwToInterruptStaticGeneration,\n  trackDynamicDataInDynamicRender,\n} from '../app-render/dynamic-rendering'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport {\n  makeDevtoolsIOAwarePromise,\n  makeHangingPromise,\n} from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { isRequestAPICallableInsideAfter } from './utils'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { RenderStage } from '../app-render/staged-rendering'\n\n/**\n * This function allows you to read the HTTP incoming request headers in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers) and\n * [Middleware](https://nextjs.org/docs/app/building-your-application/routing/middleware).\n *\n * Read more: [Next.js Docs: `headers`](https://nextjs.org/docs/app/api-reference/functions/headers)\n */\nexport function headers(): Promise<ReadonlyHeaders> {\n  const callingExpression = 'headers'\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workStore) {\n    if (\n      workUnitStore &&\n      workUnitStore.phase === 'after' &&\n      !isRequestAPICallableInsideAfter()\n    ) {\n      throw new Error(\n        `Route ${workStore.route} used \\`headers()\\` inside \\`after()\\`. This is not supported. If you need this data inside an \\`after()\\` callback, use \\`headers()\\` outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`\n      )\n    }\n\n    if (workStore.forceStatic) {\n      // When using forceStatic we override all other logic and always just return an empty\n      // headers object without tracking\n      const underlyingHeaders = HeadersAdapter.seal(new Headers({}))\n      return makeUntrackedHeaders(underlyingHeaders)\n    }\n\n    if (workUnitStore) {\n      switch (workUnitStore.type) {\n        case 'cache': {\n          const error = new Error(\n            `Route ${workStore.route} used \\`headers()\\` inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`headers()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n          )\n          Error.captureStackTrace(error, headers)\n          workStore.invalidDynamicUsageError ??= error\n          throw error\n        }\n        case 'unstable-cache':\n          throw new Error(\n            `Route ${workStore.route} used \\`headers()\\` inside a function cached with \\`unstable_cache()\\`. Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \\`headers()\\` outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n          )\n        case 'prerender':\n        case 'prerender-client':\n        case 'private-cache':\n        case 'prerender-runtime':\n        case 'prerender-ppr':\n        case 'prerender-legacy':\n        case 'request':\n          break\n        default:\n          workUnitStore satisfies never\n      }\n    }\n\n    if (workStore.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`headers()\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      switch (workUnitStore.type) {\n        case 'prerender':\n          return makeHangingHeaders(workStore, workUnitStore)\n        case 'prerender-client':\n          const exportName = '`headers`'\n          throw new InvariantError(\n            `${exportName} must not be used within a client component. Next.js should be preventing ${exportName} from being included in client components statically, but did not in this case.`\n          )\n        case 'prerender-ppr':\n          // PPR Prerender (no cacheComponents)\n          // We are prerendering with PPR. We need track dynamic access here eagerly\n          // to keep continuity with how headers has worked in PPR without cacheComponents.\n          // TODO consider switching the semantic to throw on property access instead\n          return postponeWithTracking(\n            workStore.route,\n            callingExpression,\n            workUnitStore.dynamicTracking\n          )\n        case 'prerender-legacy':\n          // Legacy Prerender\n          // We are in a legacy static generation mode while prerendering\n          // We track dynamic access here so we don't need to wrap the headers in\n          // individual property access tracking.\n          return throwToInterruptStaticGeneration(\n            callingExpression,\n            workStore,\n            workUnitStore\n          )\n        case 'prerender-runtime':\n          return delayUntilRuntimeStage(\n            workUnitStore,\n            makeUntrackedHeaders(workUnitStore.headers)\n          )\n        case 'private-cache':\n          // Private caches are delayed until the runtime stage in use-cache-wrapper,\n          // so we don't need an additional delay here.\n          return makeUntrackedHeaders(workUnitStore.headers)\n        case 'request':\n          trackDynamicDataInDynamicRender(workUnitStore)\n\n          if (process.env.NODE_ENV === 'development') {\n            // Semantically we only need the dev tracking when running in `next dev`\n            // but since you would never use next dev with production NODE_ENV we use this\n            // as a proxy so we can statically exclude this code from production builds.\n            return makeUntrackedHeadersWithDevWarnings(\n              workUnitStore.headers,\n              workStore?.route,\n              workUnitStore\n            )\n          } else {\n            return makeUntrackedHeaders(workUnitStore.headers)\n          }\n          break\n        default:\n          workUnitStore satisfies never\n      }\n    }\n  }\n\n  // If we end up here, there was no work store or work unit store present.\n  throwForMissingRequestStore(callingExpression)\n}\n\ninterface CacheLifetime {}\nconst CachedHeaders = new WeakMap<CacheLifetime, Promise<ReadonlyHeaders>>()\n\nfunction makeHangingHeaders(\n  workStore: WorkStore,\n  prerenderStore: PrerenderStoreModern\n): Promise<ReadonlyHeaders> {\n  const cachedHeaders = CachedHeaders.get(prerenderStore)\n  if (cachedHeaders) {\n    return cachedHeaders\n  }\n\n  const promise = makeHangingPromise<ReadonlyHeaders>(\n    prerenderStore.renderSignal,\n    workStore.route,\n    '`headers()`'\n  )\n  CachedHeaders.set(prerenderStore, promise)\n\n  return promise\n}\n\nfunction makeUntrackedHeaders(\n  underlyingHeaders: ReadonlyHeaders\n): Promise<ReadonlyHeaders> {\n  const cachedHeaders = CachedHeaders.get(underlyingHeaders)\n  if (cachedHeaders) {\n    return cachedHeaders\n  }\n\n  const promise = Promise.resolve(underlyingHeaders)\n  CachedHeaders.set(underlyingHeaders, promise)\n\n  return promise\n}\n\nfunction makeUntrackedHeadersWithDevWarnings(\n  underlyingHeaders: ReadonlyHeaders,\n  route: string | undefined,\n  requestStore: RequestStore\n): Promise<ReadonlyHeaders> {\n  if (requestStore.asyncApiPromises) {\n    const promise = requestStore.asyncApiPromises.headers\n    return instrumentHeadersPromiseWithDevWarnings(promise, route)\n  }\n\n  const cachedHeaders = CachedHeaders.get(underlyingHeaders)\n  if (cachedHeaders) {\n    return cachedHeaders\n  }\n\n  const promise = makeDevtoolsIOAwarePromise(\n    underlyingHeaders,\n    requestStore,\n    RenderStage.Runtime\n  )\n\n  const proxiedPromise = instrumentHeadersPromiseWithDevWarnings(promise, route)\n\n  CachedHeaders.set(underlyingHeaders, proxiedPromise)\n\n  return proxiedPromise\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createHeadersAccessError\n)\n\nfunction instrumentHeadersPromiseWithDevWarnings(\n  promise: Promise<ReadonlyHeaders>,\n  route: string | undefined\n) {\n  Object.defineProperties(promise, {\n    [Symbol.iterator]: replaceableWarningDescriptorForSymbolIterator(\n      promise,\n      route\n    ),\n    append: replaceableWarningDescriptor(promise, 'append', route),\n    delete: replaceableWarningDescriptor(promise, 'delete', route),\n    get: replaceableWarningDescriptor(promise, 'get', route),\n    has: replaceableWarningDescriptor(promise, 'has', route),\n    set: replaceableWarningDescriptor(promise, 'set', route),\n    getSetCookie: replaceableWarningDescriptor(promise, 'getSetCookie', route),\n    forEach: replaceableWarningDescriptor(promise, 'forEach', route),\n    keys: replaceableWarningDescriptor(promise, 'keys', route),\n    values: replaceableWarningDescriptor(promise, 'values', route),\n    entries: replaceableWarningDescriptor(promise, 'entries', route),\n  })\n  return promise\n}\n\nfunction replaceableWarningDescriptor(\n  target: unknown,\n  prop: string,\n  route: string | undefined\n) {\n  return {\n    enumerable: false,\n    get() {\n      warnForSyncAccess(route, `\\`headers().${prop}\\``)\n      return undefined\n    },\n    set(value: unknown) {\n      Object.defineProperty(target, prop, {\n        value,\n        writable: true,\n        configurable: true,\n      })\n    },\n    configurable: true,\n  }\n}\n\nfunction replaceableWarningDescriptorForSymbolIterator(\n  target: unknown,\n  route: string | undefined\n) {\n  return {\n    enumerable: false,\n    get() {\n      warnForSyncAccess(route, '`...headers()` or similar iteration')\n      return undefined\n    },\n    set(value: unknown) {\n      Object.defineProperty(target, Symbol.iterator, {\n        value,\n        writable: true,\n        enumerable: true,\n        configurable: true,\n      })\n    },\n    configurable: true,\n  }\n}\n\nfunction createHeadersAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`headers()\\` returns a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n","import {\n  getDraftModeProviderForCacheScope,\n  throwForMissingRequestStore,\n} from '../app-render/work-unit-async-storage.external'\n\nimport type { DraftModeProvider } from '../async-storage/draft-mode-provider'\n\nimport {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\nimport {\n  abortAndThrowOnSynchronousRequestDataAccess,\n  delayUntilRuntimeStage,\n  postponeWithTracking,\n  trackDynamicDataInDynamicRender,\n} from '../app-render/dynamic-rendering'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\n\nexport function draftMode(): Promise<DraftMode> {\n  const callingExpression = 'draftMode'\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (!workStore || !workUnitStore) {\n    throwForMissingRequestStore(callingExpression)\n  }\n\n  switch (workUnitStore.type) {\n    case 'prerender-runtime':\n      // TODO(runtime-ppr): does it make sense to delay this? normally it's always microtasky\n      return delayUntilRuntimeStage(\n        workUnitStore,\n        createOrGetCachedDraftMode(workUnitStore.draftMode, workStore)\n      )\n    case 'request':\n      return createOrGetCachedDraftMode(workUnitStore.draftMode, workStore)\n\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n      // Inside of `\"use cache\"` or `unstable_cache`, draft mode is available if\n      // the outmost work unit store is a request store (or a runtime prerender),\n      // and if draft mode is enabled.\n      const draftModeProvider = getDraftModeProviderForCacheScope(\n        workStore,\n        workUnitStore\n      )\n\n      if (draftModeProvider) {\n        return createOrGetCachedDraftMode(draftModeProvider, workStore)\n      }\n\n    // Otherwise, we fall through to providing an empty draft mode.\n    // eslint-disable-next-line no-fallthrough\n    case 'prerender':\n    case 'prerender-client':\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n      // Return empty draft mode\n      return createOrGetCachedDraftMode(null, workStore)\n\n    default:\n      return workUnitStore satisfies never\n  }\n}\n\nfunction createOrGetCachedDraftMode(\n  draftModeProvider: DraftModeProvider | null,\n  workStore: WorkStore | undefined\n): Promise<DraftMode> {\n  const cacheKey = draftModeProvider ?? NullDraftMode\n  const cachedDraftMode = CachedDraftModes.get(cacheKey)\n\n  if (cachedDraftMode) {\n    return cachedDraftMode\n  }\n\n  if (process.env.NODE_ENV === 'development' && !workStore?.isPrefetchRequest) {\n    const route = workStore?.route\n    return createDraftModeWithDevWarnings(draftModeProvider, route)\n  } else {\n    return Promise.resolve(new DraftMode(draftModeProvider))\n  }\n}\n\ninterface CacheLifetime {}\nconst NullDraftMode = {}\nconst CachedDraftModes = new WeakMap<CacheLifetime, Promise<DraftMode>>()\n\nfunction createDraftModeWithDevWarnings(\n  underlyingProvider: null | DraftModeProvider,\n  route: undefined | string\n): Promise<DraftMode> {\n  const instance = new DraftMode(underlyingProvider)\n  const promise = Promise.resolve(instance)\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      switch (prop) {\n        case 'isEnabled':\n          warnForSyncAccess(route, `\\`draftMode().${prop}\\``)\n          break\n        case 'enable':\n        case 'disable': {\n          warnForSyncAccess(route, `\\`draftMode().${prop}()\\``)\n          break\n        }\n        default: {\n          // We only warn for well-defined properties of the draftMode object.\n        }\n      }\n\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n  })\n\n  return proxiedPromise\n}\n\nclass DraftMode {\n  /**\n   * @internal - this declaration is stripped via `tsc --stripInternal`\n   */\n  private readonly _provider: null | DraftModeProvider\n\n  constructor(provider: null | DraftModeProvider) {\n    this._provider = provider\n  }\n  get isEnabled() {\n    if (this._provider !== null) {\n      return this._provider.isEnabled\n    }\n    return false\n  }\n  public enable() {\n    // We have a store we want to track dynamic data access to ensure we\n    // don't statically generate routes that manipulate draft mode.\n    trackDynamicDraftMode('draftMode().enable()', this.enable)\n    if (this._provider !== null) {\n      this._provider.enable()\n    }\n  }\n  public disable() {\n    trackDynamicDraftMode('draftMode().disable()', this.disable)\n    if (this._provider !== null) {\n      this._provider.disable()\n    }\n  }\n}\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createDraftModeAccessError\n)\n\nfunction createDraftModeAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`draftMode()\\` returns a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction trackDynamicDraftMode(expression: string, constructorOpt: Function) {\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workStore) {\n    // We have a store we want to track dynamic data access to ensure we\n    // don't statically generate routes that manipulate draft mode.\n    if (workUnitStore?.phase === 'after') {\n      throw new Error(\n        `Route ${workStore.route} used \"${expression}\" inside \\`after()\\`. The enabled status of \\`draftMode()\\` can be read inside \\`after()\\` but you cannot enable or disable \\`draftMode()\\`. See more info here: https://nextjs.org/docs/app/api-reference/functions/after`\n      )\n    }\n\n    if (workStore.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      switch (workUnitStore.type) {\n        case 'cache':\n        case 'private-cache': {\n          const error = new Error(\n            `Route ${workStore.route} used \"${expression}\" inside \"use cache\". The enabled status of \\`draftMode()\\` can be read in caches but you must not enable or disable \\`draftMode()\\` inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n          )\n          Error.captureStackTrace(error, constructorOpt)\n          workStore.invalidDynamicUsageError ??= error\n          throw error\n        }\n        case 'unstable-cache':\n          throw new Error(\n            `Route ${workStore.route} used \"${expression}\" inside a function cached with \\`unstable_cache()\\`. The enabled status of \\`draftMode()\\` can be read in caches but you must not enable or disable \\`draftMode()\\` inside a cache. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n          )\n\n        case 'prerender':\n        case 'prerender-runtime': {\n          const error = new Error(\n            `Route ${workStore.route} used ${expression} without first calling \\`await connection()\\`. See more info here: https://nextjs.org/docs/messages/next-prerender-sync-headers`\n          )\n          return abortAndThrowOnSynchronousRequestDataAccess(\n            workStore.route,\n            expression,\n            error,\n            workUnitStore\n          )\n        }\n        case 'prerender-client':\n          const exportName = '`draftMode`'\n          throw new InvariantError(\n            `${exportName} must not be used within a Client Component. Next.js should be preventing ${exportName} from being included in Client Components statically, but did not in this case.`\n          )\n        case 'prerender-ppr':\n          return postponeWithTracking(\n            workStore.route,\n            expression,\n            workUnitStore.dynamicTracking\n          )\n        case 'prerender-legacy':\n          workUnitStore.revalidate = 0\n\n          const err = new DynamicServerError(\n            `Route ${workStore.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n          )\n          workStore.dynamicUsageDescription = expression\n          workStore.dynamicUsageStack = err.stack\n\n          throw err\n        case 'request':\n          trackDynamicDataInDynamicRender(workUnitStore)\n          break\n        default:\n          workUnitStore satisfies never\n      }\n    }\n  }\n}\n","module.exports.cookies = require('./dist/server/request/cookies').cookies\nmodule.exports.headers = require('./dist/server/request/headers').headers\nmodule.exports.draftMode = require('./dist/server/request/draft-mode').draftMode\n"],"names":["RequestCookies","ResponseCookies","stringifyCookie","ReflectAdapter","get","target","prop","receiver","value","Reflect","bind","set","has","deleteProperty","MutableRequestCookiesAdapter","ReadonlyRequestCookiesError","RequestCookiesAdapter","appendMutableCookies","areCookiesMutableInCurrentPhase","createCookiesWithMutableAccessCheck","getModifiedCookieValues","responseCookiesToRequestCookies","Error","constructor","callable","seal","cookies","Proxy","SYMBOL_MODIFY_COOKIE_VALUES","Symbol","for","modified","Array","isArray","length","headers","mutableCookies","modifiedCookieValues","resCookies","returnedCookies","getAll","cookie","wrap","onUpdateCookies","responseCookies","Headers","modifiedValues","modifiedCookies","Set","updateResponseCookies","workStore","workAsyncStorage","getStore","pathWasRevalidated","allCookies","filter","c","name","serializedCookies","tempCookies","push","toString","wrappedCookies","args","add","delete","requestStore","ensureCookiesAreStillMutable","phase","_callingExpression","requestCookies","createDedupedByCallsiteServerErrorLoggerDev","errorRef","current","cache","React","fn","logErrorOrWarn","process","env","__NEXT_CACHE_COMPONENTS","console","error","warn","flushCurrentErrorIfNew","key","getMessage","logDedupedError","message","NODE_ENV","callStackFrames","stack","split","undefined","isRequestAPICallableInsideAfter","throwForSearchParamsAccessInUseCache","throwWithStaticGenerationBailoutErrorWithDynamicError","route","expression","StaticGenBailoutError","constructorOpt","captureStackTrace","invalidDynamicUsageError","afterTaskStore","afterTaskAsyncStorage","rootTaskSpawnPhase","callingExpression","workUnitStore","workUnitAsyncStorage","forceStatic","underlyingCookies","createEmptyCookies","makeUntrackedCookies","dynamicShouldError","type","makeHangingCookies","exportName","InvariantError","postponeWithTracking","dynamicTracking","throwToInterruptStaticGeneration","delayUntilRuntimeStage","trackDynamicDataInDynamicRender","userspaceMutableCookies","makeUntrackedCookiesWithDevWarnings","throwForMissingRequestStore","CachedCookies","WeakMap","prerenderStore","cachedPromise","promise","makeHangingPromise","renderSignal","cachedCookies","Promise","resolve","asyncApiPromises","instrumentCookiesPromiseWithDevWarnings","makeDevtoolsIOAwarePromise","RenderStage","Runtime","proxiedPromise","warnForSyncAccess","createCookiesAccessError","Object","defineProperties","iterator","replaceableWarningDescriptorForSymbolIterator","size","replaceableWarningDescriptor","clear","enumerable","defineProperty","writable","configurable","prefix","HeadersAdapter","ReadonlyHeadersError","lowercased","toLowerCase","original","keys","find","o","merge","join","from","append","existing","forEach","callbackfn","thisArg","entries","call","values","underlyingHeaders","makeUntrackedHeaders","makeHangingHeaders","makeUntrackedHeadersWithDevWarnings","CachedHeaders","cachedHeaders","instrumentHeadersPromiseWithDevWarnings","createHeadersAccessError","getSetCookie","draftMode","createOrGetCachedDraftMode","draftModeProvider","getDraftModeProviderForCacheScope","cacheKey","NullDraftMode","cachedDraftMode","CachedDraftModes","isPrefetchRequest","createDraftModeWithDevWarnings","DraftMode","underlyingProvider","instance","provider","_provider","isEnabled","enable","trackDynamicDraftMode","disable","createDraftModeAccessError","abortAndThrowOnSynchronousRequestDataAccess","revalidate","err","DynamicServerError","dynamicUsageDescription","dynamicUsageStack"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9]}